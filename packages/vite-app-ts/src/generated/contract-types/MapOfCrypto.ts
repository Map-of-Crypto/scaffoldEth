/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export declare namespace MapOfCrypto {
  export type PurchaseStruct = {
    purchaseId: BigNumberish;
    merchantAddress: string;
    buyerAddress: string;
    accepted: boolean;
    deadline: BigNumberish;
    ethPrice: BigNumberish;
    ethFunded: BigNumberish;
    trackingNumber: string;
  };

  export type PurchaseStructOutput = [BigNumber, string, string, boolean, BigNumber, BigNumber, BigNumber, string] & {
    purchaseId: BigNumber;
    merchantAddress: string;
    buyerAddress: string;
    accepted: boolean;
    deadline: BigNumber;
    ethPrice: BigNumber;
    ethFunded: BigNumber;
    trackingNumber: string;
  };
}

export interface MapOfCryptoInterface extends utils.Interface {
  contractName: 'MapOfCrypto';
  functions: {
    'acceptOwnership()': FunctionFragment;
    'acceptPurchaseRequest(uint256)': FunctionFragment;
    'balances(address)': FunctionFragment;
    'bytes32ToString(bytes32)': FunctionFragment;
    'cancelPurchase(uint256)': FunctionFragment;
    'cancelRequest(bytes32,uint256,bytes4,uint256)': FunctionFragment;
    'checkNeedPayment(bytes)': FunctionFragment;
    'checkUpkeep(bytes)': FunctionFragment;
    'fulfillPurchaseRequest(uint256,string)': FunctionFragment;
    'fullfillMerchantAPI(bytes32,bytes32,address,uint256,uint256)': FunctionFragment;
    'fullfillPurchasesToPay(bytes32,uint256[])': FunctionFragment;
    'fundPurchase(uint256)': FunctionFragment;
    'getChainlinkToken()': FunctionFragment;
    'getDataMerchantAPI(uint256,uint256)': FunctionFragment;
    'getPurchaseList()': FunctionFragment;
    'getPurchasesToPay()': FunctionFragment;
    'makePurchaseRequest(uint256,uint256)': FunctionFragment;
    'owner()': FunctionFragment;
    'performUpkeep(bytes)': FunctionFragment;
    'purchases(uint256)': FunctionFragment;
    'timeout()': FunctionFragment;
    'transferOwnership(address)': FunctionFragment;
    'withdraw(address)': FunctionFragment;
    'withdrawLink()': FunctionFragment;
  };

  encodeFunctionData(functionFragment: 'acceptOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'acceptPurchaseRequest', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'balances', values: [string]): string;
  encodeFunctionData(functionFragment: 'bytes32ToString', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'cancelPurchase', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'cancelRequest',
    values: [BytesLike, BigNumberish, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'checkNeedPayment', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'checkUpkeep', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'fulfillPurchaseRequest', values: [BigNumberish, string]): string;
  encodeFunctionData(
    functionFragment: 'fullfillMerchantAPI',
    values: [BytesLike, BytesLike, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'fullfillPurchasesToPay', values: [BytesLike, BigNumberish[]]): string;
  encodeFunctionData(functionFragment: 'fundPurchase', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getChainlinkToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getDataMerchantAPI', values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'getPurchaseList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getPurchasesToPay', values?: undefined): string;
  encodeFunctionData(functionFragment: 'makePurchaseRequest', values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'performUpkeep', values: [BytesLike]): string;
  encodeFunctionData(functionFragment: 'purchases', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'timeout', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [string]): string;
  encodeFunctionData(functionFragment: 'withdraw', values: [string]): string;
  encodeFunctionData(functionFragment: 'withdrawLink', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'acceptOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'acceptPurchaseRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'balances', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'bytes32ToString', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancelPurchase', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancelRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkNeedPayment', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'checkUpkeep', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fulfillPurchaseRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fullfillMerchantAPI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fullfillPurchasesToPay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'fundPurchase', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getChainlinkToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getDataMerchantAPI', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPurchaseList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getPurchasesToPay', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'makePurchaseRequest', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'performUpkeep', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'purchases', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'timeout', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawLink', data: BytesLike): Result;

  events: {
    'ChainlinkCancelled(bytes32)': EventFragment;
    'ChainlinkFulfilled(bytes32)': EventFragment;
    'ChainlinkRequested(bytes32)': EventFragment;
    'CheckPurchase(uint256)': EventFragment;
    'KValue(uint256)': EventFragment;
    'OwnershipTransferRequested(address,address)': EventFragment;
    'OwnershipTransferred(address,address)': EventFragment;
    'Payment(address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ChainlinkCancelled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ChainlinkFulfilled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ChainlinkRequested'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CheckPurchase'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'KValue'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferRequested'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Payment'): EventFragment;
}

export type ChainlinkCancelledEvent = TypedEvent<[string], { id: string }>;

export type ChainlinkCancelledEventFilter = TypedEventFilter<ChainlinkCancelledEvent>;

export type ChainlinkFulfilledEvent = TypedEvent<[string], { id: string }>;

export type ChainlinkFulfilledEventFilter = TypedEventFilter<ChainlinkFulfilledEvent>;

export type ChainlinkRequestedEvent = TypedEvent<[string], { id: string }>;

export type ChainlinkRequestedEventFilter = TypedEventFilter<ChainlinkRequestedEvent>;

export type CheckPurchaseEvent = TypedEvent<[BigNumber], { arg0: BigNumber }>;

export type CheckPurchaseEventFilter = TypedEventFilter<CheckPurchaseEvent>;

export type KValueEvent = TypedEvent<[BigNumber], { arg0: BigNumber }>;

export type KValueEventFilter = TypedEventFilter<KValueEvent>;

export type OwnershipTransferRequestedEvent = TypedEvent<[string, string], { from: string; to: string }>;

export type OwnershipTransferRequestedEventFilter = TypedEventFilter<OwnershipTransferRequestedEvent>;

export type OwnershipTransferredEvent = TypedEvent<[string, string], { from: string; to: string }>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export type PaymentEvent = TypedEvent<[string, BigNumber], { merchantAddress: string; ethPrice: BigNumber }>;

export type PaymentEventFilter = TypedEventFilter<PaymentEvent>;

export interface MapOfCrypto extends BaseContract {
  contractName: 'MapOfCrypto';
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MapOfCryptoInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    acceptPurchaseRequest(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    balances(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    bytes32ToString(_bytes32: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    cancelPurchase(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelRequest(
      _requestId: BytesLike,
      _payment: BigNumberish,
      _callbackFunctionId: BytesLike,
      _expiration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkNeedPayment(
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkUpkeep(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean, string] & { upkeepNeeded: boolean; performData: string }>;

    fulfillPurchaseRequest(
      purchaseId: BigNumberish,
      packageTrackingNumber: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fullfillMerchantAPI(
      _requestId: BytesLike,
      _currency: BytesLike,
      _merchantAddress: string,
      _price: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fullfillPurchasesToPay(
      _requestId: BytesLike,
      purchaseNeedFunding: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fundPurchase(
      purchaseId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getChainlinkToken(overrides?: CallOverrides): Promise<[string]>;

    getDataMerchantAPI(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getPurchaseList(overrides?: CallOverrides): Promise<[MapOfCrypto.PurchaseStructOutput[]]>;

    getPurchasesToPay(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    makePurchaseRequest(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    performUpkeep(
      performData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    purchases(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, boolean, BigNumber, BigNumber, BigNumber, string] & {
        purchaseId: BigNumber;
        merchantAddress: string;
        buyerAddress: string;
        accepted: boolean;
        deadline: BigNumber;
        ethPrice: BigNumber;
        ethFunded: BigNumber;
        trackingNumber: string;
      }
    >;

    timeout(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdraw(target: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    withdrawLink(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;
  };

  acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  acceptPurchaseRequest(
    purchaseId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  bytes32ToString(_bytes32: BytesLike, overrides?: CallOverrides): Promise<string>;

  cancelPurchase(
    purchaseId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelRequest(
    _requestId: BytesLike,
    _payment: BigNumberish,
    _callbackFunctionId: BytesLike,
    _expiration: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkNeedPayment(
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkUpkeep(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<[boolean, string] & { upkeepNeeded: boolean; performData: string }>;

  fulfillPurchaseRequest(
    purchaseId: BigNumberish,
    packageTrackingNumber: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fullfillMerchantAPI(
    _requestId: BytesLike,
    _currency: BytesLike,
    _merchantAddress: string,
    _price: BigNumberish,
    productId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fullfillPurchasesToPay(
    _requestId: BytesLike,
    purchaseNeedFunding: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fundPurchase(
    purchaseId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getChainlinkToken(overrides?: CallOverrides): Promise<string>;

  getDataMerchantAPI(
    merchantId: BigNumberish,
    productId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getPurchaseList(overrides?: CallOverrides): Promise<MapOfCrypto.PurchaseStructOutput[]>;

  getPurchasesToPay(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  makePurchaseRequest(
    merchantId: BigNumberish,
    productId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  performUpkeep(
    performData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  purchases(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, string, boolean, BigNumber, BigNumber, BigNumber, string] & {
      purchaseId: BigNumber;
      merchantAddress: string;
      buyerAddress: string;
      accepted: boolean;
      deadline: BigNumber;
      ethPrice: BigNumber;
      ethFunded: BigNumber;
      trackingNumber: string;
    }
  >;

  timeout(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    to: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdraw(target: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  withdrawLink(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    acceptPurchaseRequest(purchaseId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    bytes32ToString(_bytes32: BytesLike, overrides?: CallOverrides): Promise<string>;

    cancelPurchase(purchaseId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    cancelRequest(
      _requestId: BytesLike,
      _payment: BigNumberish,
      _callbackFunctionId: BytesLike,
      _expiration: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    checkNeedPayment(data: BytesLike, overrides?: CallOverrides): Promise<void>;

    checkUpkeep(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean, string] & { upkeepNeeded: boolean; performData: string }>;

    fulfillPurchaseRequest(
      purchaseId: BigNumberish,
      packageTrackingNumber: string,
      overrides?: CallOverrides
    ): Promise<void>;

    fullfillMerchantAPI(
      _requestId: BytesLike,
      _currency: BytesLike,
      _merchantAddress: string,
      _price: BigNumberish,
      productId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    fullfillPurchasesToPay(
      _requestId: BytesLike,
      purchaseNeedFunding: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    fundPurchase(purchaseId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    getChainlinkToken(overrides?: CallOverrides): Promise<string>;

    getDataMerchantAPI(merchantId: BigNumberish, productId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    getPurchaseList(overrides?: CallOverrides): Promise<MapOfCrypto.PurchaseStructOutput[]>;

    getPurchasesToPay(overrides?: CallOverrides): Promise<void>;

    makePurchaseRequest(merchantId: BigNumberish, productId: BigNumberish, overrides?: CallOverrides): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    performUpkeep(performData: BytesLike, overrides?: CallOverrides): Promise<void>;

    purchases(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, string, boolean, BigNumber, BigNumber, BigNumber, string] & {
        purchaseId: BigNumber;
        merchantAddress: string;
        buyerAddress: string;
        accepted: boolean;
        deadline: BigNumber;
        ethPrice: BigNumber;
        ethFunded: BigNumber;
        trackingNumber: string;
      }
    >;

    timeout(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(to: string, overrides?: CallOverrides): Promise<void>;

    withdraw(target: string, overrides?: CallOverrides): Promise<void>;

    withdrawLink(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    'ChainlinkCancelled(bytes32)'(id?: BytesLike | null): ChainlinkCancelledEventFilter;
    ChainlinkCancelled(id?: BytesLike | null): ChainlinkCancelledEventFilter;

    'ChainlinkFulfilled(bytes32)'(id?: BytesLike | null): ChainlinkFulfilledEventFilter;
    ChainlinkFulfilled(id?: BytesLike | null): ChainlinkFulfilledEventFilter;

    'ChainlinkRequested(bytes32)'(id?: BytesLike | null): ChainlinkRequestedEventFilter;
    ChainlinkRequested(id?: BytesLike | null): ChainlinkRequestedEventFilter;

    'CheckPurchase(uint256)'(arg0?: null): CheckPurchaseEventFilter;
    CheckPurchase(arg0?: null): CheckPurchaseEventFilter;

    'KValue(uint256)'(arg0?: null): KValueEventFilter;
    KValue(arg0?: null): KValueEventFilter;

    'OwnershipTransferRequested(address,address)'(
      from?: string | null,
      to?: string | null
    ): OwnershipTransferRequestedEventFilter;
    OwnershipTransferRequested(from?: string | null, to?: string | null): OwnershipTransferRequestedEventFilter;

    'OwnershipTransferred(address,address)'(from?: string | null, to?: string | null): OwnershipTransferredEventFilter;
    OwnershipTransferred(from?: string | null, to?: string | null): OwnershipTransferredEventFilter;

    'Payment(address,uint256)'(merchantAddress?: null, ethPrice?: null): PaymentEventFilter;
    Payment(merchantAddress?: null, ethPrice?: null): PaymentEventFilter;
  };

  estimateGas: {
    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    acceptPurchaseRequest(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    balances(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    bytes32ToString(_bytes32: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    cancelPurchase(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelRequest(
      _requestId: BytesLike,
      _payment: BigNumberish,
      _callbackFunctionId: BytesLike,
      _expiration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    checkNeedPayment(data: BytesLike, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    checkUpkeep(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    fulfillPurchaseRequest(
      purchaseId: BigNumberish,
      packageTrackingNumber: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fullfillMerchantAPI(
      _requestId: BytesLike,
      _currency: BytesLike,
      _merchantAddress: string,
      _price: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fullfillPurchasesToPay(
      _requestId: BytesLike,
      purchaseNeedFunding: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fundPurchase(
      purchaseId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getChainlinkToken(overrides?: CallOverrides): Promise<BigNumber>;

    getDataMerchantAPI(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getPurchaseList(overrides?: CallOverrides): Promise<BigNumber>;

    getPurchasesToPay(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    makePurchaseRequest(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    performUpkeep(
      performData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    purchases(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    timeout(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(to: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    withdraw(target: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    withdrawLink(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    acceptPurchaseRequest(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    balances(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bytes32ToString(_bytes32: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancelPurchase(
      purchaseId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelRequest(
      _requestId: BytesLike,
      _payment: BigNumberish,
      _callbackFunctionId: BytesLike,
      _expiration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkNeedPayment(
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkUpkeep(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fulfillPurchaseRequest(
      purchaseId: BigNumberish,
      packageTrackingNumber: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fullfillMerchantAPI(
      _requestId: BytesLike,
      _currency: BytesLike,
      _merchantAddress: string,
      _price: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fullfillPurchasesToPay(
      _requestId: BytesLike,
      purchaseNeedFunding: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fundPurchase(
      purchaseId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getChainlinkToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDataMerchantAPI(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getPurchaseList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPurchasesToPay(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    makePurchaseRequest(
      merchantId: BigNumberish,
      productId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    performUpkeep(
      performData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    purchases(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timeout(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawLink(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;
  };
}
